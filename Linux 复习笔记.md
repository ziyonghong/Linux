## chapter 1

#### 操作系统的组成

操作系统=内核+系统程序。

系统程序=编译环境+API(应用程序接口)+AUI（用户接口）

编译环境=编译程序+连接程序+装载程序

API=系统调用+语言库函数（C,C++,Java等）

AUI=shell+系统服务例程（X服务器等）+应用程序（浏览器、字处理、编辑器等）



软件系统=操作系统+AUI



操作系统标准POSIX表示可移植操作系统接口。



#### Linux内核技术特点

Linux被设计称 **单内核** 结构，单内核就是从整体上把内核作为一个大过程来实现，而进程管理、内存管理等是其中的一个个模块，模块之间可以直接调用相关的函数。效率高，紧凑性强。

微内核是一种功能更贴近硬件的核心软件，它一般仅仅包括基本的内存管理、同步原语、进程间通信机制、IO操作和中断管理，这样做有利于提高可扩展性和可移植性，但微内核与文件管理、设备驱动、虚拟内存管理、进程管理等其他上层模块之间需要有较高的通信开销。



#### Linux内核的位置

整个系统由四部分组成：

1.用户进程

2.系统调用接口

3.Liunx内核

4.硬件

![](F:\Desktop\Typora\Linux\Linux内核的位置.png)



#### Linux内核体系结构

1.进程调度--控制着进程对CPU的访问。当需要选择一个进程运行时，由调度程序选择最值得运行的进程。

2.虚拟文件系统（VFS）--隐藏各种不同硬件的具体细节，为所有设备提供统一的接口。

3.进程间通信--支持进程间各种通信机制，包括共享内存、消息队列及管道等。



## chapter 2

#### 80x86常用寄存器

通用寄存器、段寄存器、指令指针寄存器、标志寄存器和控制寄存器。

供一般用户使用：通用寄存器EAX,EBX,ECX,EDX，EBP(基址指针)，ESP(堆栈指针),ESI(扩展源指针),EDI(扩展目的指针)，还有EFLAGS(标志寄存器).

专供操作系统使用的寄存器：IDTR中断描述符寄存器，GDTR全局描述符表寄存器，LDTR局部描述符表寄存器，TaskRegisters任务寄存器，DebugRegister调试寄存器，ControlRegister控制寄存器，Model-SpecificRegisters模型专用寄存器。



#### 物理地址、虚拟地址、线性地址

主板上的物理内存条所提供的内存空间为物理内存空间，其中每个内存单元的实际地址是物理地址。

程序员看到的内存空间为虚拟地址空间，其中的地址为虚拟地址，一般用“段：偏移量”形式描述。

线性地址空间是一段连续的，不分段的，范围为0到4GB的地址空间，一个线性地址是线性地址空间的绝对地址。

![](F:\Desktop\Typora\Linux\虚拟地址-物理地址.png)



#### 段描述符

段的基地址：在线性地址空间中段的起始地址。

段的界限：在虚拟地址空间中，段内可以使用的最大偏移量。

段的保护属性：表示段的特性，例如，是否可读写，可执行及段的特权级等。



#### 分页机制

完成线性地址--物理地址的转换。

把线性地址空间划分成页面，然后这些线性地址空间页面被映射到物理地址空间的页面上。



```
为什么在设计两级页表的线性地址结构时，给页目录和页表各分配10位？如果不是这 样，举例说明会产生什么样的结果？  
答：所谓两级页表就是对页表再进行分页。第一级称为页目录，其中存放的是关于页表的信息。4MB的页表再次分页（4MB／4K）可以分为1K个页，同样对每个页的描述需要4个字节，于是可以算出页目录最多占用4KB个字节，正好是一个页，其示意图如2.9所示。
页目录共有1K个表项， 于是，线性地址的最高10位(即22位~ 31位)用来产生第一级的索引。两级表结构的第二级称为页表，每个页表也刚好存放在一个4K字节的页中，包含1K个字节的表项。第二级页表由线性地址的中间10位(即21位~ 12位)进行索引，最低12位表示页内偏量。
 
举例：如果页目录占用31~24位，页表项占用23~12位，偏移地址占11~0位，则有2^8个页表项，一个页面有2^12（4k）个表项，每个表项大小为4字节，2^12的范围为4页面，而不是以一个页面为准。
```

```
叙述线性地址到物理地址的转换。

第一步，用32位线性地址的最高10位第31~22位作为页目录项的索引，将它乘以4，与CR3中页目录的起始地址相加，获得相应目录项在内存的地址；
第二步，从这个地址开始读取32位页目录项，取出其高20位，再给低12位补0，形成的32位就是页表在内存的起始地址；
第三步，用32位线性地址中的第21~12位作为页表中页表项的索引，将它乘以4，与页表的起始地址相加，获得相应页表项在内存的地址；
第四，从这个地址开始读取32位页表项，取出其高20位，再将线性地址的第11~0位放在低12位，最终形成32位页面物理地址。
```

### chapter 3

进程是由 **正文段、用户数据段以及** 共同组成的一个执行环境。



#### 进程的状态

运行态-->阻塞态：进程发生IO请求或等待某事情。

运行态-->就绪态：调度程序引起，系统认为运行进程占用CPU的时间过长，决定让其他进程占用CPU。

就绪态--> 运行态：运行进程已经用完分给它的CPU时间，调度程序从处于就绪态的进程中选择一个投入运行。

阻塞态-->就绪态：当一个进程等待的一个外部事件发生时（如输入数据到达）会发生这种转换。



#### 进程控制块PCB

1.状态信息--描述进程动态的变化

2.链接信息--描述进程的亲属关系，如父进程等

3.各种标识符--用简单数字对进程进行标识，如进程标识符

4.进程间通信信息--描述多个进程在同一任务上协作工作，如管道、消息队列等

5.时间和定时器信息--描述进程在生存周期内使用CPU时间的统计、计费等信息

6.调度信息--描述进程优先级、调度策略等信息，如静态优先级、时间片轮转、高优先级及多级反馈队列等的调度策略



#### 深睡眠状态与浅睡眠状态区别

浅睡眠状态：进程正在睡眠（被阻塞），等待资源有效时被唤醒，可以由其他进程通过信号或时钟中断唤醒。

深睡眠状态：其他进程发来的信号和时钟中断不能打断其睡眠。



#### 进程标识符PID

每个进程都有一个唯一的进程标识符，内核通过这个标志符来识别不同的进程，同时，进程标识符PID也是内核提供给拥堵程序的接口，用户程序可以通过PID对进程发号施令。