## chapter 1

#### 操作系统的组成

操作系统=内核+系统程序。

系统程序=编译环境+API(应用程序接口)+AUI（用户接口）

编译环境=编译程序+连接程序+装载程序

API=系统调用+语言库函数（C,C++,Java等）

AUI=shell+系统服务例程（X服务器等）+应用程序（浏览器、字处理、编辑器等）



软件系统=操作系统+AUI



操作系统标准POSIX表示可移植操作系统接口。



#### Linux内核技术特点

Linux被设计称 **单内核** 结构，单内核就是从整体上把内核作为一个大过程来实现，而进程管理、内存管理等是其中的一个个模块，模块之间可以直接调用相关的函数。效率高，紧凑性强。

微内核是一种功能更贴近硬件的核心软件，它一般仅仅包括基本的内存管理、同步原语、进程间通信机制、IO操作和中断管理，这样做有利于提高可扩展性和可移植性，但微内核与文件管理、设备驱动、虚拟内存管理、进程管理等其他上层模块之间需要有较高的通信开销。



#### Linux内核的位置

整个系统由四部分组成：

1.用户进程

2.系统调用接口

3.Liunx内核

4.硬件

![](F:\Desktop\Typora\Linux\Linux内核的位置.png)



#### Linux内核体系结构

1.进程调度--控制着进程对CPU的访问。当需要选择一个进程运行时，由调度程序选择最值得运行的进程。

2.虚拟文件系统（VFS）--隐藏各种不同硬件的具体细节，为所有设备提供统一的接口。

3.进程间通信--支持进程间各种通信机制，包括共享内存、消息队列及管道等。



## chapter 2 内存寻址

#### 80x86常用寄存器

通用寄存器、段寄存器、指令指针寄存器、标志寄存器和控制寄存器。

供一般用户使用：通用寄存器EAX,EBX,ECX,EDX，EBP(基址指针)，ESP(堆栈指针),ESI(扩展源指针),EDI(扩展目的指针)，还有EFLAGS(标志寄存器).

专供操作系统使用的寄存器：IDTR中断描述符寄存器，GDTR全局描述符表寄存器，LDTR局部描述符表寄存器，TaskRegisters任务寄存器，DebugRegister调试寄存器，ControlRegister控制寄存器，Model-SpecificRegisters模型专用寄存器。



#### 物理地址、虚拟地址、线性地址

主板上的物理内存条所提供的内存空间为物理内存空间，其中每个内存单元的实际地址是物理地址。

程序员看到的内存空间为虚拟地址空间，其中的地址为虚拟地址，一般用“段：偏移量”形式描述。

线性地址空间是一段连续的，不分段的，范围为0到4GB的地址空间，一个线性地址是线性地址空间的绝对地址。

![](F:\Desktop\Typora\Linux\虚拟地址-物理地址.png)



#### 段描述符

段的基地址：在线性地址空间中段的起始地址。

段的界限：在虚拟地址空间中，段内可以使用的最大偏移量。

段的保护属性：表示段的特性，例如，是否可读写，可执行及段的特权级等。



#### 分页机制

完成线性地址--物理地址的转换。

把线性地址空间划分成页面，然后这些线性地址空间页面被映射到物理地址空间的页面上。



```
为什么在设计两级页表的线性地址结构时，给页目录和页表各分配10位？如果不是这 样，举例说明会产生什么样的结果？  
答：所谓两级页表就是对页表再进行分页。第一级称为页目录，其中存放的是关于页表的信息。4MB的页表再次分页（4MB／4K）可以分为1K个页，同样对每个页的描述需要4个字节，于是可以算出页目录最多占用4KB个字节，正好是一个页，其示意图如2.9所示。
页目录共有1K个表项， 于是，线性地址的最高10位(即22位~ 31位)用来产生第一级的索引。两级表结构的第二级称为页表，每个页表也刚好存放在一个4K字节的页中，包含1K个字节的表项。第二级页表由线性地址的中间10位(即21位~ 12位)进行索引，最低12位表示页内偏量。
 
举例：如果页目录占用31~24位，页表项占用23~12位，偏移地址占11~0位，则有2^8个页表项，一个页面有2^12（4k）个表项，每个表项大小为4字节，2^12的范围为4页面，而不是以一个页面为准。
```

```
叙述线性地址到物理地址的转换。

第一步，用32位线性地址的最高10位第31~22位作为页目录项的索引，将它乘以4，与CR3中页目录的起始地址相加，获得相应目录项在内存的地址；
第二步，从这个地址开始读取32位页目录项，取出其高20位，再给低12位补0，形成的32位就是页表在内存的起始地址；
第三步，用32位线性地址中的第21~12位作为页表中页表项的索引，将它乘以4，与页表的起始地址相加，获得相应页表项在内存的地址；
第四，从这个地址开始读取32位页表项，取出其高20位，再将线性地址的第11~0位放在低12位，最终形成32位页面物理地址。
```

## chapter 3 进程

进程是由 **正文段、用户数据段以及** 共同组成的一个执行环境。



#### 进程的状态

运行态-->阻塞态：进程发生IO请求或等待某事情。

运行态-->就绪态：调度程序引起，系统认为运行进程占用CPU的时间过长，决定让其他进程占用CPU。

就绪态--> 运行态：运行进程已经用完分给它的CPU时间，调度程序从处于就绪态的进程中选择一个投入运行。

阻塞态-->就绪态：当一个进程等待的一个外部事件发生时（如输入数据到达）会发生这种转换。



#### 进程控制块PCB

1.状态信息--描述进程动态的变化

2.链接信息--描述进程的亲属关系，如父进程等

3.各种标识符--用简单数字对进程进行标识，如进程标识符

4.进程间通信信息--描述多个进程在同一任务上协作工作，如管道、消息队列等

5.时间和定时器信息--描述进程在生存周期内使用CPU时间的统计、计费等信息

6.调度信息--描述进程优先级、调度策略等信息，如静态优先级、时间片轮转、高优先级及多级反馈队列等的调度策略



#### 深睡眠状态与浅睡眠状态区别

浅睡眠状态：进程正在睡眠（被阻塞），等待资源有效时被唤醒，可以由其他进程通过信号或时钟中断唤醒。

深睡眠状态：其他进程发来的信号和时钟中断不能打断其睡眠。



#### 进程标识符PID

每个进程都有一个唯一的进程标识符，内核通过这个标志符来识别不同的进程，同时，进程标识符PID也是内核提供给拥堵程序的接口，用户程序可以通过PID对进程发号施令。



#### 进程调度

主要的调度算法：

1.时间片轮转调度算法

2.优先权调度算法

3.多级反馈队列调度

4.实时调度

Linux调度程序提高交互式程序的优先级，让它们运行得更频繁。



#### 进程的创建

fork()通过拷贝当前进程创建一个子进程，然后， exec()函数负责读取可执行文件并将其载入进程的地址空间开始运行。

不管是fork()还是clone()系统调用，最终都是调用了内核中的do_fork()函数。



```
PCB的组织方式有哪几种？为什么要采取这些组织方式
答：（1）进程链表（2）哈希表（3）就绪队列（4）等待队列 
在一个系统中，通常可以拥有数十个、数百个乃至数千个进程，相应的就有这么多PCB。为了能有效的对它们加以管理，应该用适当的方式将这些PCB组织起来。
```

```
7、什么是写时复制技术，这种技术在什么情况下最能发挥其优势？ 
答：父进程和子进程共享页面而不是复制页面。然而，只要页面被共享，它们就不能被修改。无论父进程和子进程何时试图写一个共享的页面，就产生一个错误，这时内核就把这个页复制到一个新的页面中并标记为可写。原来的页面仍然是写保护的：当其它进程试图写入时，内核检查写进程是否是这个页面的唯一属主；如果是，它把这个页面标记为对这个进程是可写的。采用这种技术，显然只有预测到将要修改的页才会被复制，而且必须被复制，不然的话，就会破坏父进程的程序执行。
```



## chapter 4 内存管理

#### 虚拟内存、内核空间和用户空间

Linux内核将4GB的虚拟地址空间分成两部分。

最高的1GB（从虚地址0xC0000000到0xFFFFFFFF）供内核使用，称内核空间

较低4GB（从虚地址0x00000000到0xBFFFFFFF）供进程使用，称用户空间

因为每个进程可以通过系统调用进入内核，因此，Linux内核空间由系统内的所有进程共享。



#### 虚存映射

Linux并不将映像装入到物理内存，相反，可执行文件只是从磁盘映射到进程的用户空间。随着进程的运行，被引用的程序部分会由操作系统装入到物理内存，这种将映像链接到进程用户空间的方法就是“虚存映射”

两种类型的映射：共享的和私有的

当可执行映像映射到进程的用户空间时，产生一组vm_area_struct结构来描述各个虚拟区间的起始点和终止点，每个vm_area_struct代表可执行映像的一部分，可能是可执行代码、初始化的变量或未初始化的数据，这些映射都是通过mmap()系统调用对应的do_mmap()内核函数实现的。



#### 请页机制

页故障的产生原因：

1.程序出现错误，如要访问的虚地址在PAGE_OFFSET之外，该地址无效

2.虚地址有效，但其所对应的页当前不在物理内存中，即缺页异常。这时操作系统必须从磁盘或交换文件（此页被换出）中将其装入物理内存。

3.要访问的虚地址被写保护，即保护错误



虚存区的访问权限与引起缺页异常的访问类型相匹配，需调用handle_mm_fault()函数给进程分配一个新的物理页面：

请求调页：如果被访问的页不在内存，这个页还没有被存放在任何一个物理页面中，那么，内核分配一个新的页面并适当地初始化的技术。

请求调页是一种动态内存分配技术，它把页面的分配一直推迟到进程要访问的页不在物理内存时为止，由此引起一个缺页异常。该技术的引入主要是因为进程开始运行时并不访问其地址空间中的全部地址。

写时复制：如果被访问的页在内存但是被标为只读，即它已经被放在一个页面中，那么，内核分配一个新的页面，并把旧的页面的数据拷贝到新页面来初始化它的技术。 好处：避免拷贝大量不会使用的数据。



#### 伙伴算法

```
试叙述伙伴算法的工作原理，并说明为什么伙伴算法可以消除外碎片？ 
答：假设要求分配的块其大小为128个页面。该算法先在块大小为128个页面的链表中查找，看是否有这样一个空闲块。如果有，就直接分配；如果没有，该算法会查找下一个更大的块，具体地说，就是在块大小为256个页面的链表中查找一个空闲块。如果存在这样的空闲块，内核就把这256个页面分为两等份，一份分配出去，另一份插入到块大小为128个页面的链表中。如果在块大小为256个页面的链表中也没有找到空闲页块，就继续找更大的块，即512个页面的块。如果存在这样的块，内核就从512个页面的块中分出128个页面满足请求，然后从384个页面中取出256个页面插入到块大小为256个页面的链表中。然后把剩余的128个页面插入到块大小为128个页面的链表中。如果512个页面的链表中还没有空闲块，该算法就放弃分配，并发出出错信号。
```



#### 交换机制

每个进程可以使用的虚存空间很大，但实际使用的空间并不大，需有把内存的内容与一个专用的磁盘空间交换的技术。Linux中，把用作交换的磁盘空间叫做交换文件或交换区。

Linux中，交换的单位是页面而不是进程（进程换入换出时，上下文切换的代价太高），实际上交换的是页面中存放的数据。

1.哪种页面被换出？只有与用户空间建立了映射关系的物理页面才会被换出去，而内核空间中内核所占的页面则常驻内存。

2.如何在交换区中存放页面？交换区也被划分为块，一块叫一个页插槽，而且每个块的大小正好等于一页，可以把一个物理页面插入到一个插槽中。

3.如何选择被交换出的页面？ 

策略一，需要时才交换。

策略二：系统空闲时交换。

策略三：换出但并不立即释放。

策略四：把页面换出推迟到不能推迟为止。



```
4.3 内核空间存放什么内容？如何把其中一个虚拟地址转换成物理地址？ 
答：内核空间存放的是内核代码和数据。给定一个虚拟地址x，其物理地址为x-PAGE_OFFSET(一般为3GB，表示虚拟地址和物理地址之间的位移量) 
4.4什么是内核映像？它存放在物理空间和内核空间的什么地方？ 
答：内核空间由所有进程共享，其中存放的是内核代码和数据，即“内核映象” 
Linux内核映像被装入在物理地址0x00100000开始的地方 内核映像在内核空间的起始地址就为0xC0100000。
```



